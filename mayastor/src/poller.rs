use spdk_sys::{spdk_poller, spdk_poller_register, spdk_poller_unregister};
use std::{ops::Deref, os::raw::c_void};

#[derive(Debug)]
pub struct PollTask {
    /// pointer to the allocated poller
    poller: *mut spdk_poller,
}

/// signature of the poll function, this is similar as the function generated by
/// bindgen but does not require the user of this interface to deal with the
/// Option
pub type PollFunction = extern "C" fn(*mut c_void) -> i32;

/// create a new poller returning Option<PollTask> or None in case of failure
/// the Poll task must be dropped explicitly during a shutdown.
pub fn register_poller<T: Deref>(
    poll_fn: PollFunction,
    interval: u64,
    ctx: &T,
) -> Option<PollTask> {
    let poller = unsafe {
        spdk_poller_register(
            Some(poll_fn),
            *(&*ctx as *const _ as *const _),
            interval,
        )
    };

    if poller.is_null() {
        None
    } else {
        Some(PollTask {
            poller,
        })
    }
}

impl Drop for PollTask {
    fn drop(&mut self) {
        if !self.poller.is_null() {
            trace!("deregister poller {:?}", self.poller);
            unsafe {
                spdk_poller_unregister(&mut self.poller);
                self.poller = std::ptr::null_mut();
            }
        }
    }
}
